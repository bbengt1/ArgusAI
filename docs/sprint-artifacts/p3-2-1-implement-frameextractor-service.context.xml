<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>P3-2</epicId>
    <storyId>1</storyId>
    <title>Implement FrameExtractor Service</title>
    <status>drafted</status>
    <generatedAt>2025-12-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/p3-2-1-implement-frameextractor-service.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system</asA>
    <iWant>to extract multiple frames from video clips</iWant>
    <soThat>AI can analyze a sequence of images showing action over time</soThat>
    <tasks>
      <task id="1" ac="1,2,3,4">Create FrameExtractor service
        <subtask id="1.1">Create backend/app/services/frame_extractor.py</subtask>
        <subtask id="1.2">Implement FrameExtractor class with singleton pattern (like ClipService)</subtask>
        <subtask id="1.3">Add get_frame_extractor() function for dependency injection</subtask>
        <subtask id="1.4">Add logging with structured extra={} dict pattern</subtask>
      </task>
      <task id="2" ac="1,2,3">Implement extract_frames method
        <subtask id="2.1">Accept clip_path: Path, frame_count: int = 5, strategy: str = "evenly_spaced" parameters</subtask>
        <subtask id="2.2">Open video with PyAV using av.open(str(clip_path))</subtask>
        <subtask id="2.3">Get total frame count and duration from container</subtask>
        <subtask id="2.4">Calculate frame indices based on evenly_spaced strategy</subtask>
        <subtask id="2.5">Seek to each frame index and decode frame</subtask>
        <subtask id="2.6">Convert frame to numpy array for encoding</subtask>
        <subtask id="2.7">Return list of JPEG-encoded bytes</subtask>
      </task>
      <task id="3" ac="2,3">Implement evenly_spaced frame selection
        <subtask id="3.1">Calculate frame indices: [0, duration/(count-1), 2*duration/(count-1), ..., duration]</subtask>
        <subtask id="3.2">Always include first frame (index 0)</subtask>
        <subtask id="3.3">Always include last frame (total_frames - 1)</subtask>
        <subtask id="3.4">Round intermediate frame indices to nearest integer</subtask>
        <subtask id="3.5">Handle edge case: clip shorter than frame_count (return all available frames)</subtask>
      </task>
      <task id="4" ac="1">Implement frame encoding
        <subtask id="4.1">Add _encode_frame(frame: np.ndarray) -> bytes private method</subtask>
        <subtask id="4.2">Use OpenCV or PIL to encode as JPEG at 85% quality</subtask>
        <subtask id="4.3">Resize to max 1280px width if larger (maintain aspect ratio)</subtask>
        <subtask id="4.4">Return JPEG bytes</subtask>
      </task>
      <task id="5" ac="4">Add error handling
        <subtask id="5.1">Catch av.AVError and other PyAV exceptions</subtask>
        <subtask id="5.2">Catch FileNotFoundError for missing clip files</subtask>
        <subtask id="5.3">Return empty list on any extraction error</subtask>
        <subtask id="5.4">Log errors with extra={"clip_path": str, "error": str} pattern</subtask>
      </task>
      <task id="6" ac="3">Add configuration settings
        <subtask id="6.1">Add FRAME_EXTRACT_DEFAULT_COUNT to settings (default: 5)</subtask>
        <subtask id="6.2">Add FRAME_EXTRACT_MIN_COUNT (default: 3)</subtask>
        <subtask id="6.3">Add FRAME_EXTRACT_MAX_COUNT (default: 10)</subtask>
        <subtask id="6.4">Add FRAME_JPEG_QUALITY to settings (default: 85)</subtask>
        <subtask id="6.5">Add FRAME_MAX_WIDTH to settings (default: 1280)</subtask>
      </task>
      <task id="7" ac="All">Write unit tests
        <subtask id="7.1">Test extract_frames returns correct number of frames</subtask>
        <subtask id="7.2">Test evenly_spaced strategy calculates correct timestamps</subtask>
        <subtask id="7.3">Test frame_count=3 works correctly</subtask>
        <subtask id="7.4">Test frame_count=10 works correctly</subtask>
        <subtask id="7.5">Test invalid file returns empty list</subtask>
        <subtask id="7.6">Test corrupted video returns empty list</subtask>
        <subtask id="7.7">Test frames are valid JPEG bytes</subtask>
        <subtask id="7.8">Test first and last frames are always included</subtask>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1">Given a valid MP4 clip file path, when FrameExtractor.extract_frames(clip_path, frame_count=5) is called, then returns a list of 5 JPEG-encoded frame bytes and extraction completes within 2 seconds for 10-second clips (NFR2)</ac>
    <ac id="2">Given a 10-second video clip, when extracting 5 frames with "evenly_spaced" strategy, then frames are extracted at 0s, 2.5s, 5s, 7.5s, 10s and first and last frames are always included</ac>
    <ac id="3">Given frame_count parameter between 3-10 (FR8), when extraction is called, then exactly that many frames are returned and spacing adjusts proportionally to clip duration</ac>
    <ac id="4">Given an invalid or corrupted video file, when extraction is attempted, then returns empty list and logs error with file path and reason</ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture - FrameExtractor</title>
        <section>Phase 3 Service Architecture - FrameExtractor (NEW)</section>
        <snippet>FrameExtractor extracts frames from video clips using PyAV, selects frames using configurable strategy, filters low-quality frames (blur detection), and encodes as JPEG for AI analysis. Key methods: extract_frames(), _is_frame_usable(), _encode_frame().</snippet>
      </doc>
      <doc>
        <path>docs/epics-phase3.md</path>
        <title>Phase 3 Epics - Story P3-2.1</title>
        <section>Epic P3-2: Multi-Frame Analysis Mode (MVP)</section>
        <snippet>Story P3-2.1 implements FrameExtractor service for extracting frames from video clips. Includes evenly-spaced selection (3-10 frames), JPEG encoding, and error handling for corrupted files.</snippet>
      </doc>
      <doc>
        <path>docs/sprint-artifacts/p3-1-5-add-clip-download-api-endpoint-for-testing.md</path>
        <title>Previous Story - P3-1.5</title>
        <section>Dev Agent Record - Learnings</section>
        <snippet>PyAV integration established: av.open(str(clip_path)) pattern, container.duration (microseconds), container.streams.video[0]. Error handling returns gracefully with logging.</snippet>
      </doc>
    </docs>

    <code>
      <file>
        <path>backend/app/services/clip_service.py</path>
        <kind>service</kind>
        <symbol>ClipService, get_clip_service, reset_clip_service</symbol>
        <lines>1-750</lines>
        <reason>Reference implementation for singleton pattern, PyAV usage (download_clip uses similar video handling), structured logging patterns, and cleanup patterns. FrameExtractor should follow the same patterns.</reason>
      </file>
      <file>
        <path>backend/tests/test_services/test_clip_service.py</path>
        <kind>test</kind>
        <symbol>TestClipServiceInit, TestDownloadClip, TestClipServiceSingleton</symbol>
        <lines>1-1385</lines>
        <reason>Reference test patterns for singleton services, mocking PyAV, async testing patterns, error handling tests. FrameExtractor tests should follow similar structure.</reason>
      </file>
      <file>
        <path>backend/app/api/v1/protect.py</path>
        <kind>api</kind>
        <symbol>_get_video_duration</symbol>
        <lines>1142-1174</lines>
        <reason>Example of PyAV video duration extraction helper function. Similar pattern can be used for frame extraction.</reason>
      </file>
      <file>
        <path>backend/app/services/__init__.py</path>
        <kind>module</kind>
        <symbol>services module</symbol>
        <lines>all</lines>
        <reason>May need to export get_frame_extractor from services module.</reason>
      </file>
    </code>

    <dependencies>
      <python>
        <package name="av" version=">=12.0.0">PyAV for video frame extraction - already installed</package>
        <package name="pillow" version=">=10.0.0">PIL for JPEG encoding - already installed</package>
        <package name="numpy" version="implied">NumPy for frame array handling - implied by opencv-python</package>
        <package name="opencv-python" version=">=4.12.0">OpenCV for optional frame processing - already installed</package>
      </python>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="pattern">Use singleton pattern matching ClipService (get_frame_extractor() function, reset_frame_extractor() for tests)</constraint>
    <constraint type="pattern">Use structured logging with extra={} dict pattern for all log calls</constraint>
    <constraint type="pattern">Return empty list on error (never raise exceptions from public methods)</constraint>
    <constraint type="pattern">Use async def for extract_frames (consistency with ClipService)</constraint>
    <constraint type="nfr">NFR2: Frame extraction must complete within 2 seconds for 10-second clips</constraint>
    <constraint type="fr">FR8: frame_count parameter must accept values between 3-10</constraint>
    <constraint type="quality">JPEG encoding at 85% quality for balance of size and clarity</constraint>
    <constraint type="quality">Max width 1280px to reduce AI token cost while preserving detail</constraint>
    <constraint type="architecture">Place new service at backend/app/services/frame_extractor.py</constraint>
    <constraint type="architecture">Place tests at backend/tests/test_services/test_frame_extractor.py</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>FrameExtractor.extract_frames</name>
      <kind>async method</kind>
      <signature>async def extract_frames(self, clip_path: Path, frame_count: int = 5, strategy: str = "evenly_spaced") -> List[bytes]</signature>
      <path>backend/app/services/frame_extractor.py</path>
    </interface>
    <interface>
      <name>FrameExtractor._calculate_frame_indices</name>
      <kind>private method</kind>
      <signature>def _calculate_frame_indices(self, total_frames: int, frame_count: int) -> List[int]</signature>
      <path>backend/app/services/frame_extractor.py</path>
    </interface>
    <interface>
      <name>FrameExtractor._encode_frame</name>
      <kind>private method</kind>
      <signature>def _encode_frame(self, frame: np.ndarray) -> bytes</signature>
      <path>backend/app/services/frame_extractor.py</path>
    </interface>
    <interface>
      <name>get_frame_extractor</name>
      <kind>singleton factory</kind>
      <signature>def get_frame_extractor() -> FrameExtractor</signature>
      <path>backend/app/services/frame_extractor.py</path>
    </interface>
    <interface>
      <name>reset_frame_extractor</name>
      <kind>test helper</kind>
      <signature>def reset_frame_extractor() -> None</signature>
      <path>backend/app/services/frame_extractor.py</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Tests follow pytest patterns with pytest-asyncio for async methods. Use MagicMock/AsyncMock for mocking dependencies. Test files located in backend/tests/test_services/. Use fixtures with autouse for setup/teardown. Mock external dependencies (PyAV) for unit tests. Use tempfile for test video files. Test both success and error paths. Follow existing test patterns in test_clip_service.py.
    </standards>
    <locations>
      <location>backend/tests/test_services/test_frame_extractor.py</location>
      <location>backend/tests/test_services/ (adjacent to test_clip_service.py)</location>
    </locations>
    <ideas>
      <idea ac="1">Test extract_frames returns correct number of frames for frame_count=5</idea>
      <idea ac="1">Test JPEG bytes start with FFD8 (JPEG magic bytes) for all returned frames</idea>
      <idea ac="1">Test extraction completes within 2 seconds performance threshold (mock or small test video)</idea>
      <idea ac="2">Test evenly_spaced calculates correct indices for 10-second clip with 5 frames</idea>
      <idea ac="2">Test first frame is always index 0</idea>
      <idea ac="2">Test last frame is always total_frames - 1</idea>
      <idea ac="3">Test frame_count=3 returns exactly 3 frames</idea>
      <idea ac="3">Test frame_count=10 returns exactly 10 frames</idea>
      <idea ac="3">Test frame_count > total_frames returns all available frames</idea>
      <idea ac="4">Test FileNotFoundError returns empty list and logs error</idea>
      <idea ac="4">Test corrupted video returns empty list and logs error</idea>
      <idea ac="4">Test av.AVError is caught and returns empty list</idea>
      <idea ac="all">Test singleton pattern (get_frame_extractor returns same instance)</idea>
      <idea ac="all">Test reset_frame_extractor clears singleton</idea>
    </ideas>
  </tests>
</story-context>
